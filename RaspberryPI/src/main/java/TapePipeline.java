
import java.util.ArrayList;
import java.util.List;

import org.opencv.core.*;
import org.opencv.imgproc.Imgproc;

import edu.wpi.first.vision.VisionPipeline;

/**
 * TapePipelineNew class.
 *
 * <p>An OpenCV pipeline generated by GRIP.
 *
 * @author GRIP
 */
class TapePipeline implements VisionPipeline
{
    static {
        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
    }

    // inputs
    private static final Scalar redScalar = new Scalar(0, 0, 255);
    private static final Scalar whiteScalar = new Scalar(255, 255, 255);
    private static final Scalar blackScalar = new Scalar(0, 0, 0);

    //Outputs
    private Mat input = new Mat();
    private Mat hslThresholdOutput = new Mat();
    private ArrayList<MatOfPoint> findContours = new ArrayList<>();
    private ArrayList<RotatedRect> filteredRotatedRects = new ArrayList<>();

    private TapeInfo tapeInfo = null;  // null when no lock

    // Dynamic setting of Threshold values;
    private static double[] hslThresholdHue = {30.0, 100.0};
    private static double[] hslThresholdSaturation = {0.0, 50.0};
    private static double[] hslThresholdValue = {200.0, 255.0};

    private static double rotatedRectMinArea = 200.0;
    private static double[] rectRatio = {0.25, 0.5};

    static void setThresholdHue(double min, double max)
    {
        hslThresholdHue[0] = min;
        hslThresholdHue[1] = max;
    }

    static double[] getThresholdHue()
    {
        return hslThresholdHue;
    }

    static void setThresholdSaturation(double min, double max)
    {
        hslThresholdSaturation[0] = min;
        hslThresholdSaturation[1] = max;
    }

    static double[] getThresholdSaturation()
    {
        return hslThresholdSaturation;
    }

    static void setThresholdValue(double min, double max)
    {
        hslThresholdValue[0] = min;
        hslThresholdValue[1] = max;
    }

    static double[] getThresholdValue()
    {
        return hslThresholdValue;
    }

    static void setRotatedRectMinArea(double min)
    {
        rotatedRectMinArea = min;
    }

    static double getRotatedRectMinArea()
    {
        return rotatedRectMinArea;
    }

    static void setRotatedRectRatio(double min, double max)
    {
        rectRatio[0] = min;
        rectRatio[1] = max;
    }

    static double[] getRotatedRectRatio()
    {
        return rectRatio;
    }

    /**
     * This is the primary method that runs the entire pipeline and updates the outputs.
     */
    @Override
    public void process(Mat source0)
    {
        input = source0;
        Rect crop = new Rect(0, 0, input.width(), input.height() / 2);  // Upper half of screen only
        Mat subImage = input.submat(crop);

        hsvThreshold(subImage, hslThresholdHue, hslThresholdSaturation, hslThresholdValue, hslThresholdOutput);
        findContours(hslThresholdOutput, false, findContours);

        // Populate RotatedRects from the contours and filter out those that have a bad ratio or too small.
        MatOfPoint2f mat2f = new MatOfPoint2f();
        filteredRotatedRects.clear();
        for (MatOfPoint contour : findContours) {
            contour.convertTo(mat2f, CvType.CV_32F);
            RotatedRect rect = Imgproc.minAreaRect(mat2f);
            double ratio = (rect.size.width < rect.size.height) ? rect.size.width / rect.size.height : rect.size.height / rect.size.width;

            // If ratio is good and big enough, add the Contour and RotatedRect to output
            if (ratio >= rectRatio[0] && ratio <= rectRatio[1] && (rect.size.width * rect.size.height) > rotatedRectMinArea) {
                filteredRotatedRects.add(rect);
            }
        }

        tapeInfo = TapeFinder.findTapeLockInfo(filteredRotatedRects, input.width(), input.height(), tapeInfo);  // will reuse tapeInfo if not null
    }

    Mat getInput()
    {
        return input;
    }

    Mat hslThresholdOutput()
    {
        return hslThresholdOutput;
    }

    ArrayList<MatOfPoint> getFindContours()
    {
        return findContours;
    }

    ArrayList<RotatedRect> getfilteredRotatedRects()
    {
        return filteredRotatedRects;
    }

    TapeInfo getTapeInfo()
    {
        return tapeInfo;
    }

    /**
     * Segment an image based on hue, saturation, and value ranges.
     *
     * @param input The image on which to perform the HSL threshold.
     * @param hue   The min and max hue
     * @param sat   The min and max saturation
     * @param val   The min and max value
     * @param out   The image in which to store the output.
     */
    private static void hsvThreshold(Mat input, double[] hue, double[] sat, double[] val, Mat out)
    {
        Imgproc.cvtColor(input, out, Imgproc.COLOR_BGR2HSV);
        Core.inRange(out, new Scalar(hue[0], sat[0], val[0]),
                new Scalar(hue[1], sat[1], val[1]), out);
    }

    /**
     * Sets the values of pixels in a binary image to their distance to the nearest black pixel.
     *
     * @param input        The image on which to perform the Distance Transform.
     * @param externalOnly Look for external contours only.
     * @param contours     the List of contours to populate
     */
    @SuppressWarnings("SameParameterValue")
    private void findContours(Mat input, boolean externalOnly, List<MatOfPoint> contours)
    {
        Mat hierarchy = new Mat();
        contours.clear();

        int mode = (externalOnly ? Imgproc.RETR_EXTERNAL : Imgproc.RETR_LIST);
        int method = Imgproc.CHAIN_APPROX_SIMPLE;
        Imgproc.findContours(input, contours, hierarchy, mode, method);
    }

    void renderContours(List<RotatedRect> rotatedRects, Mat output, boolean debug)
    {
        double fontScale = (output.width() > 352 ? 1.0 : 0.7);

        for (RotatedRect rotatedRect : rotatedRects) {
            Point[] vertices = new Point[4];
            rotatedRect.points(vertices);
            for (int j = 0; j < 4; j++)
                Imgproc.line(output, vertices[j], vertices[(j + 1) % 4], redScalar, 2);

            if (debug) {
                Point p = rotatedRect.center.clone();
                double angle = Math.round( ((rotatedRect.size.width < rotatedRect.size.height) ? rotatedRect.angle + 90 : rotatedRect.angle ) * 10.0 ) / 10.0;
                double yaw = Camera.yawToHorizontalPixel( rotatedRect.center.x,output.width() );
                int area = (int)Math.round(rotatedRect.size.width * rotatedRect.size.height);

                double dy = 15;
                p.y += dy;
                Imgproc.putText(output, "/" + angle, p, Core.FONT_HERSHEY_PLAIN, fontScale, blackScalar, 3);
                Imgproc.putText(output, "/" + angle, p, Core.FONT_HERSHEY_PLAIN, fontScale, whiteScalar, 1);

                p.y += dy;
                String t = "C(" + Math.round(rotatedRect.center.x) + ", "
                        + Math.round(rotatedRect.center.y) + ")";
                Imgproc.putText(output, t, p, Core.FONT_HERSHEY_PLAIN, fontScale, blackScalar, 3);
                Imgproc.putText(output, t, p, Core.FONT_HERSHEY_PLAIN, fontScale, whiteScalar, 1);

                p.y += dy;
                t = "B(" + rotatedRect.boundingRect().width + ", "
                        + rotatedRect.boundingRect().height + ")";

                Imgproc.putText(output, t, p, Core.FONT_HERSHEY_PLAIN, fontScale, blackScalar, 3);
                Imgproc.putText(output, t, p, Core.FONT_HERSHEY_PLAIN, fontScale, whiteScalar, 1);

                p.y += dy;
                t = "A: " + area;

                Imgproc.putText(output, t, p, Core.FONT_HERSHEY_PLAIN, fontScale, blackScalar, 3);
                Imgproc.putText(output, t, p, Core.FONT_HERSHEY_PLAIN, fontScale, whiteScalar, 1);

                p.y += dy;
                Imgproc.putText(output, "Y: " + yaw, p, Core.FONT_HERSHEY_PLAIN, fontScale, blackScalar, 3);
                Imgproc.putText(output, "Y: " + yaw, p, Core.FONT_HERSHEY_PLAIN, fontScale, whiteScalar, 1);
            }
        }

        if (tapeInfo != null)  // We have a lock
        {
            double lineX = tapeInfo.getCenterX();
            double targetYaw = tapeInfo.getAngle();

            Imgproc.putText(output, "Yaw: " + targetYaw, new Point(lineX + 3, 10), Core.FONT_HERSHEY_PLAIN, fontScale, blackScalar, 3);
            Imgproc.putText(output, "Yaw: " + targetYaw, new Point(lineX + 3, 10), Core.FONT_HERSHEY_PLAIN, fontScale, whiteScalar, 1);
            Imgproc.line(output, new Point(lineX, 0), new Point(lineX, output.height()), whiteScalar);

            Imgproc.putText(output, "Distance: " + tapeInfo.getDistance(),
                    new Point(lineX + 3, 25), Core.FONT_HERSHEY_PLAIN, fontScale, blackScalar, 3);
            Imgproc.putText(output, "Distance: " + tapeInfo.getDistance(),
                    new Point(lineX + 3, 25), Core.FONT_HERSHEY_PLAIN, fontScale, whiteScalar, 1);

            if (debug) {
                String info = "(" + Math.round(tapeInfo.getCenterX()) + ","
                        + Math.round(tapeInfo.getCenterY()) + ","
                        + Math.round(tapeInfo.getCenterHeight()) + ")";
                Imgproc.putText(output, info, new Point(lineX + 3, 40), Core.FONT_HERSHEY_PLAIN, fontScale, blackScalar, 3);
                Imgproc.putText(output, info, new Point(lineX + 3, 40), Core.FONT_HERSHEY_PLAIN, fontScale, whiteScalar, 1);

                info = "(" + Math.round(tapeInfo.getFrameWidth()) + ","
                        + Math.round(tapeInfo.getFrameHeight()) + ")";
                Imgproc.putText(output, info, new Point(lineX + 3, 55), Core.FONT_HERSHEY_PLAIN, fontScale, blackScalar, 3);
                Imgproc.putText(output, info, new Point(lineX + 3, 55), Core.FONT_HERSHEY_PLAIN, fontScale, whiteScalar, 1);
            }
        } else {
            Imgproc.putText(output, "No Target Lock", new Point(3, output.height() - 10), Core.FONT_HERSHEY_PLAIN, fontScale * 1.25, blackScalar, 3);
            Imgproc.putText(output, "No Target Lock", new Point(3, output.height() - 10), Core.FONT_HERSHEY_PLAIN, fontScale * 1.25, redScalar, 1);
        }
    }
}
